<!DOCTYPE html>
<html>
	<head>
		<title>My experiment</title>

		<!-- jsPsych -->
		<script src="https://unpkg.com/jspsych@8.2.2"></script>
		<script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@2.1.0"></script>
		<script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.1.0"></script>
		<link
			href="https://unpkg.com/jspsych@8.2.2/css/jspsych.css"
			rel="stylesheet"
			type="text/css"
		/>

		<!-- Bootstrap 5 -->
		<link
			href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
			rel="stylesheet"
		/>
		<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

		<!-- Google Fonts -->
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@100..900&display=swap"
			rel="stylesheet"
		/>

		<!-- My Style -->
		<link rel="stylesheet" href="./assets/my_style.css" />
		<link rel="stylesheet" href="./assets/css/payoff_table.css" />
		<link rel="stylesheet" href="./assets/css/network_plt.css" />
	</head>
	<body></body>

	<script type="module">
		import { createTable } from "./assets/js/generate_table.js";
		import {
			drawBaseNetwork,
			updateParticipantsState,
			updateParticipantsPayoff,
			updateNeighborBehavior,
			updateNeighborPayoff,
		} from "./assets/js/plot_network.js";

		const jsPsych = initJsPsych();
		const js_data = jsPsych.data;

		const network_plt = `<div><svg style="width: 100%; height: 300px;" id="network-plot"></svg></div>`;
		const payoff_table = `<div class="table-responsive mt-3" id="payoff-table"></div>`;

		const bc_ratio = 6;
		const network_info = await (
			await fetch(`./assets/S1_scope_data_bc${bc_ratio}.json`)
		).json();
		// console.log(network_info);

		function shuffleArrayIndices(array) {
			const indices = Array.from(array.keys());
			for (let i = indices.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[indices[i], indices[j]] = [indices[j], indices[i]];
			}
			return indices;
		}

		function convert_action_to_html(action) {
			if (action === "cooperate") {
				return `<span class="text-success fw-bold">A</span>`;
			} else if (action === "defect") {
				return `<span class="text-warning fw-bold">B</span>`;
			} else {
				return `<span class="text-secondary fw-bold">-</span>`;
			}
		}

		function create_player_decisions(network_info_array) {
			const res_player_decisions = [];
			for (let i = 0; i < network_info_array.length; i++) {
				const player_action_html = convert_action_to_html(
					network_info_array[i].p_action_str
				);
				const situation_instruction = `<p>あなたは ${player_action_html} を選択しました</p>`;
				const expose_trial = {
					type: jsPsychHtmlButtonResponse,
					stimulus: situation_instruction + network_plt + payoff_table,
					choices: ["次へ"],
					on_load: () => {
						// Generate the payoff table when the trial loads
						createTable();
						// Draw the network when the trial loads
						drawBaseNetwork();
						updateParticipantsState(network_info_array[i].p_action_str);
					},
				};
				res_player_decisions.push(expose_trial);
			}
			return res_player_decisions;
		}

		function create_display_neighbor_actions(network_info_array) {
			const res_display_neighbor_actions = [];
			const display_instruction = `<p>つながりのある 4人の行動は以下の通りです</p>`;
			for (let i = 0; i < network_info_array.length; i++) {
				const display_trial = {
					type: jsPsychHtmlButtonResponse,
					stimulus: display_instruction + network_plt + payoff_table,
					choices: ["次へ"],
					on_load: () => {
						// Generate the payoff table when the trial loads
						createTable();
						// Draw the network when the trial loads
						drawBaseNetwork();
						updateParticipantsState(network_info_array[i].p_action_str);
						updateNeighborBehavior(network_info_array[i].neighbor_action_list);
					},
				};
				res_display_neighbor_actions.push(display_trial);
			}
			return res_display_neighbor_actions;
		}

		function create_situations_array(network_info_array) {
			const res_situations = [];
			const situation_instruction = `<p>その結果、あなたは以下の状況に置かれました</p>`;
			for (let i = 0; i < network_info_array.length; i++) {
				const expose_trial = {
					type: jsPsychHtmlButtonResponse,
					stimulus: situation_instruction + network_plt + payoff_table,
					choices: ["次へ"],
					on_load: () => {
						// Generate the payoff table when the trial loads
						createTable();
						// Draw the network when the trial loads
						drawBaseNetwork();
						updateParticipantsState(network_info_array[i].p_action_str);
						updateParticipantsPayoff(network_info_array[i].p_payoff);
						updateNeighborBehavior(network_info_array[i].neighbor_action_list);
						updateNeighborPayoff(network_info_array[i].neighbor_payoff_list);
					},
				};
				res_situations.push(expose_trial);
			}
			return res_situations;
		}

		function create_decision_tasks(network_info_array) {
			const res_decision_tasks = [];
			const decision_instruction = `<p>次に、あなたはどちらの行動を選択しますか？</p>`;
			for (let i = 0; i < network_info_array.length; i++) {
				const decision_task = {
					type: jsPsychHtmlButtonResponse,
					stimulus: decision_instruction + network_plt + payoff_table,
					choices: ["A", "B"],
					button_html: (choice) => {
						let btn_class = "";
						if (choice === "A") btn_class = "btn-success";
						if (choice === "B") btn_class = "btn-warning";
						return `<button class="btn btn-lg ${btn_class}" style="margin: 0 15px;">${choice}</button>`;
					},
					on_load: () => {
						// Generate the payoff table when the trial loads
						createTable();
						// Reset the network state when the trial loads
						drawBaseNetwork();
					},
					on_finish: (data) => {
						console.log(data);
						js_data.addProperties({
							trial_type: "decision_task",
							index: network_info_array[i].index,
							situation_id: network_info_array[i].situation_id,
							player_decision: data.response === 0 ? "cooperate" : "defect",
						});
					},
				};
				res_decision_tasks.push(decision_task);
			}
			return res_decision_tasks;
		}

		function create_feedback_screen(network_info_array) {
			function calculatePayoff(player_decision, neighbor_next_actions) {
				let payoff = 0;

				if (player_decision === "defect") {
					payoff += 4;
				}

				neighbor_next_actions.forEach((action) => {
					if (action === "cooperate") {
						payoff += bc_ratio;
					}
				});

				return payoff;
			}

			function calculateNeighborsPayoff(
				player_decision,
				previous_action,
				neighbor_next_payoffs
			) {
				if (player_decision === previous_action) {
					return neighbor_next_payoffs;
				}

				const neighbor_add_payoff =
					player_decision === "cooperate" ? bc_ratio : -bc_ratio;
				const payoffs = [];
				neighbor_next_payoffs.forEach((payoff) => {
					payoffs.push(payoff + neighbor_add_payoff);
				});
				return payoffs;
			}

			const res_feedback_screen = [];
			const feedback_instruction = `<p>あなたの選択の結果は以下の通りです</p>`;
			for (let i = 0; i < network_info_array.length; i++) {
				const feedback_trial = {
					type: jsPsychHtmlButtonResponse,
					stimulus: feedback_instruction + network_plt + payoff_table,
					choices: ["次へ"],
					on_load: () => {
						const last_data = js_data.get().last(1).values()[0];
						const previous_action = network_info_array[i].p_action_str;
						const player_decision =
							last_data.response === 0 ? "cooperate" : "defect";

						// Generate the payoff table when the trial loads
						createTable();
						// Draw the network when the trial loads
						drawBaseNetwork();
						updateParticipantsState(player_decision);

						const p_payoff = calculatePayoff(
							player_decision,
							network_info_array[i].neighbor_next_actions
						);
						updateParticipantsPayoff(p_payoff);

						updateNeighborBehavior(network_info_array[i].neighbor_next_actions);
						const neighbor_payoffs = calculateNeighborsPayoff(
							player_decision,
							previous_action,
							network_info_array[i].neighbor_next_payoffs
						);
						updateNeighborPayoff(neighbor_payoffs);

						console.log({
							player_decision: player_decision,
							p_payoff: p_payoff,
							neighbor_next_actions:
								network_info_array[i].neighbor_next_actions,
							neighbor_true_payoffs:
								network_info_array[i].neighbor_next_payoffs,
							neighbor_payoffs: neighbor_payoffs,
						});
					},
				};
				res_feedback_screen.push(feedback_trial);
			}
			return res_feedback_screen;
		}

		function combine_expose_and_decision(network_info_array) {
			const shuffled_indices = shuffleArrayIndices(network_info_array);
			const player_decisions = create_player_decisions(network_info_array);
			const display_neighbor_actions =
				create_display_neighbor_actions(network_info_array);
			const expose_situations = create_situations_array(network_info_array);
			const decision_tasks = create_decision_tasks(network_info_array);
			const feedback_screen = create_feedback_screen(network_info_array);

			const timelines = [];
			for (let i = 0; i < network_info_array.length; i++) {
				const idx = shuffled_indices[i];
				timelines.push(player_decisions[idx]);
				timelines.push(display_neighbor_actions[idx]);
				timelines.push(expose_situations[idx]);
				timelines.push(decision_tasks[idx]);
				timelines.push(feedback_screen[idx]);
			}
			return timelines;
		}

		const timelines = combine_expose_and_decision(network_info);
		jsPsych.run(timelines);
	</script>
</html>
